use std::{
    collections::{BTreeMap, BTreeSet},
    fmt::Display,
    fs::File,
    io::Write,
    num::NonZeroU16,
    path::{Path, PathBuf},
};

use color_eyre::eyre::{eyre, Context, ContextCompat};
use iroha_crypto::{Algorithm, KeyPair, PublicKey};
use iroha_data_model::{prelude::PeerId, ChainId};
use iroha_primitives::addr::{socket_addr, SocketAddr};
use peer_generator::Peer;
use serde::{ser::SerializeMap, Serialize, Serializer};

use crate::{cli::SourceParsed, util::AbsolutePath};

/// Config directory inside of the docker image
const DIR_CONFIG_IN_DOCKER: &str = "/config";
const PATH_TO_GENESIS: &str = "/config/genesis.json";
const GENESIS_KEYPAIR_SEED: &[u8; 7] = b"genesis";
const COMMAND_SUBMIT_GENESIS: &str = "iroha --submit-genesis";
const DOCKER_COMPOSE_VERSION: &str = "3.8";
const PLATFORM_ARCHITECTURE: &str = "linux/amd64";

#[derive(Serialize, Debug)]
pub struct DockerCompose {
    version: DockerComposeVersion,
    services: BTreeMap<String, DockerComposeService>,
}

impl DockerCompose {
    pub fn new(services: BTreeMap<String, DockerComposeService>) -> Self {
        Self {
            version: DockerComposeVersion,
            services,
        }
    }

    pub fn write_file(
        &self,
        path: &PathBuf,
        banner_enabled: bool,
    ) -> Result<(), color_eyre::Report> {
        let mut file = File::create(path)
            .wrap_err_with(|| eyre!("Failed to create file {}", path.display()))?;

        if banner_enabled {
            file.write_all(
                b"# This file is generated by iroha_swarm.\n\
                  # Do not edit it manually.\n\n",
            )
            .wrap_err_with(|| eyre!("Failed to write banner into {}", path.display()))?;
        }

        let yaml = serde_yaml::to_string(self).wrap_err("Failed to serialise YAML")?;
        file.write_all(yaml.as_bytes())
            .wrap_err_with(|| eyre!("Failed to write YAML content into {}", path.display()))
            .map_err(Into::into)
    }
}

#[derive(Debug)]
struct DockerComposeVersion;

impl Serialize for DockerComposeVersion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(DOCKER_COMPOSE_VERSION)
    }
}

#[derive(Debug)]
struct PlatformArchitecture;

impl Serialize for PlatformArchitecture {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(PLATFORM_ARCHITECTURE)
    }
}

pub struct DockerComposeServiceBuilder {
    chain_id: ChainId,
    peer: Peer,
    source: ServiceSource,
    volumes: Vec<(String, String)>,
    trusted_peers: BTreeSet<PeerId>,
    genesis_file: Option<String>,
    genesis_public_key: PublicKey,
    genesis_signature: Option<String>,
    health_check: bool,
}

#[derive(Serialize, Debug)]
pub struct DockerComposeService {
    #[serde(flatten)]
    source: ServiceSource,
    platform: PlatformArchitecture,
    environment: FullPeerEnv,
    ports: Vec<PairColon<u16, u16>>,
    volumes: Vec<PairColon<String, String>>,
    init: AlwaysTrue,
    #[serde(skip_serializing_if = "ServiceCommand::is_none")]
    command: ServiceCommand,
    #[serde(skip_serializing_if = "Option::is_none")]
    healthcheck: Option<HealthCheck>,
}

impl DockerComposeServiceBuilder {
    pub fn new(
        chain_id: ChainId,
        peer: Peer,
        source: ServiceSource,
        volumes: Vec<(String, String)>,
        trusted_peers: BTreeSet<PeerId>,
        genesis_file: Option<String>,
        genesis_public_key: PublicKey,
        genesis_signature: Option<String>,
    ) -> Self {
        Self {
            chain_id,
            peer,
            source,
            volumes,
            trusted_peers,
            genesis_file,
            genesis_public_key,
            genesis_signature,
            health_check: false,
        }
    }

    pub fn set_health_check(mut self, flag: bool) -> Self {
        self.health_check = flag;
        self
    }

    pub fn submit_genesis_with(mut self, genesis_signature: String) -> Self {
        self.genesis_signature = Some(genesis_signature);
        self
    }

    pub fn build(self) -> DockerComposeService {
        let Self {
            chain_id,
            peer,
            source,
            volumes,
            trusted_peers,
            genesis_file,
            genesis_public_key,
            genesis_signature,
            health_check,
        } = self;

        let ports = vec![
            PairColon(peer.port_p2p, peer.port_p2p),
            PairColon(peer.port_api, peer.port_api),
        ];

        let command = if genesis_signature.is_some() {
            ServiceCommand::SubmitGenesis
        } else {
            ServiceCommand::None
        };

        let compact_env = CompactPeerEnv {
            chain_id,
            trusted_peers,
            genesis_file,
            genesis_public_key,
            genesis_signature,
            key_pair: peer.key_pair.clone(),
            p2p_addr: socket_addr!(0.0.0.0:peer.port_p2p),
            api_addr: socket_addr!(0.0.0.0:peer.port_api),
        };

        DockerComposeService {
            source,
            platform: PlatformArchitecture,
            command,
            init: AlwaysTrue,
            volumes: volumes.into_iter().map(|(a, b)| PairColon(a, b)).collect(),
            ports,
            environment: compact_env.into(),
            healthcheck: health_check.then_some(HealthCheck {
                port: peer.port_api,
            }),
        }
    }
}

#[derive(Debug)]
struct AlwaysTrue;

impl Serialize for AlwaysTrue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_bool(true)
    }
}

#[derive(Debug)]
enum ServiceCommand {
    SubmitGenesis,
    None,
}

impl ServiceCommand {
    fn is_none(&self) -> bool {
        matches!(self, Self::None)
    }
}

impl Serialize for ServiceCommand {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::None => serializer.serialize_none(),
            Self::SubmitGenesis => serializer.serialize_str(COMMAND_SUBMIT_GENESIS),
        }
    }
}

/// Serializes as a Iroha health check according to the
/// [spec](https://docs.docker.com/compose/compose-file/compose-file-v3/#healthcheck).
#[derive(Debug)]
struct HealthCheck {
    #[allow(dead_code)]
    port: u16,
}

const HEALTH_CHECK_INTERVAL: &str = "2s"; // half of default pipeline time

const HEALTH_CHECK_TIMEOUT: &str = "1s"; // status request usually resolves immediately

const HEALTH_CHECK_RETRIES: u8 = 30u8; // try within one minute given the interval

const HEALTH_CHECK_START_PERIOD: &str = "4s"; // default pipeline time

impl Serialize for HealthCheck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut map = serializer.serialize_map(Some(5))?;
        map.serialize_entry(
            "test",
            &format!(
                "test $(curl -s http://127.0.0.1:{}/status/blocks) -gt 0",
                self.port
            ),
        )?;
        map.serialize_entry("interval", HEALTH_CHECK_INTERVAL)?;
        map.serialize_entry("timeout", HEALTH_CHECK_TIMEOUT)?;
        map.serialize_entry("retries", &HEALTH_CHECK_RETRIES)?;
        map.serialize_entry("start_period", HEALTH_CHECK_START_PERIOD)?;
        map.end()
    }
}

/// Serializes as `"{0}:{1}"`
#[derive(derive_more::Display, Debug)]
#[display(fmt = "{_0}:{_1}")]
struct PairColon<T, U>(T, U)
where
    T: Display,
    U: Display;

impl<T, U> Serialize for PairColon<T, U>
where
    T: Display,
    U: Display,
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.collect_str(self)
    }
}

#[derive(Serialize, Clone, Debug)]
#[serde(rename_all = "lowercase")]
pub enum ServiceSource {
    Image(String),
    Build(PathBuf),
}

#[serde_with::serde_as]
#[serde_with::skip_serializing_none]
#[derive(Serialize, Debug)]
#[serde(rename_all = "UPPERCASE")]
struct FullPeerEnv {
    chain_id: ChainId,
    public_key: PublicKey,
    private_key_algorithm: Algorithm,
    #[serde_as(as = "serde_with::hex::Hex")]
    private_key_payload: Vec<u8>,
    p2p_address: SocketAddr,
    api_address: SocketAddr,
    genesis_file: Option<String>,
    genesis_public_key: PublicKey,
    genesis_signature: Option<String>,
    #[serde_as(as = "Option<serde_with::json::JsonString>")]
    sumeragi_trusted_peers: Option<BTreeSet<PeerId>>,
}

struct CompactPeerEnv {
    chain_id: ChainId,
    key_pair: KeyPair,
    /// Genesis file is only needed for a peer that is submitting the genesis block
    genesis_file: Option<String>,
    genesis_public_key: PublicKey,
    genesis_signature: Option<String>,
    p2p_addr: SocketAddr,
    api_addr: SocketAddr,
    trusted_peers: BTreeSet<PeerId>,
}

impl From<CompactPeerEnv> for FullPeerEnv {
    fn from(value: CompactPeerEnv) -> Self {
        let (private_key_algorithm, private_key_payload) = {
            let (algorithm, payload) = value.key_pair.private_key().clone().to_bytes();
            (algorithm, payload)
        };

        Self {
            chain_id: value.chain_id,
            public_key: value.key_pair.public_key().clone(),
            private_key_algorithm,
            private_key_payload,
            genesis_file: value.genesis_file,
            genesis_public_key: value.genesis_public_key,
            genesis_signature: value.genesis_signature,
            p2p_address: value.p2p_addr,
            api_address: value.api_addr,
            sumeragi_trusted_peers: if value.trusted_peers.is_empty() {
                None
            } else {
                Some(value.trusted_peers)
            },
        }
    }
}

#[derive(Debug)]
pub struct DockerComposeBuilder<'a> {
    /// Needed to compute a relative source build path
    pub target_file: &'a AbsolutePath,
    /// Needed to put into `volumes`
    pub config_dir: &'a AbsolutePath,
    pub image_source: ResolvedImageSource,
    pub peers: NonZeroU16,
    /// Crypto seed to use for keys generation
    pub seed: Option<&'a [u8]>,
    /// Keypair that takes precedence over seed if present
    pub key_pair: Option<String>,
    pub signature: Option<String>,
    pub health_check: bool,
}

impl DockerComposeBuilder<'_> {
    fn build(&self) -> color_eyre::Result<DockerCompose> {
        let target_file_dir = self.target_file.parent().ok_or_else(|| {
            eyre!(
                "Cannot get a directory of a file {}",
                self.target_file.display()
            )
        })?;

        let chain_id = ChainId::from("00000000-0000-0000-0000-000000000000");
        let peers = peer_generator::generate_peers(self.peers, self.seed)
            .wrap_err("Failed to generate peers")?;

        let genesis_key_pair = self.key_pair.clone().map_or(
            Ok(generate_key_pair(self.seed, GENESIS_KEYPAIR_SEED)),
            |json_key| serde_json::from_str(json_key.as_str()).map_err(|e| eyre!(e.to_string())),
        )?;

        let service_source = match &self.image_source {
            ResolvedImageSource::Build { path } => {
                ServiceSource::Build(path.relative_to(target_file_dir)?)
            }
            ResolvedImageSource::Image { name } => ServiceSource::Image(name.clone()),
        };
        let volumes = vec![(
            self.config_dir
                .relative_to(target_file_dir)?
                .to_str()
                .wrap_err("Config directory path is not a valid string")?
                .to_owned(),
            DIR_CONFIG_IN_DOCKER.to_owned(),
        )];

        let trusted_peers: BTreeSet<PeerId> = peers.values().map(Peer::id_as_a_service).collect();

        let mut peers_iter = peers.iter();

        let signature = self.signature.clone().map_or(
            generate_hex_string_signature(&chain_id, &genesis_key_pair),
            |sign| sign,
        );

        let first_peer_service = {
            let (name, peer) = peers_iter.next().expect("There is non-zero count of peers");
            let service = DockerComposeServiceBuilder::new(
                chain_id.clone(),
                peer.clone(),
                service_source.clone(),
                volumes.clone(),
                trusted_peers
                    .iter()
                    .filter(|trusted_peer| trusted_peer.public_key() != peer.key_pair.public_key())
                    .cloned()
                    .collect(),
                Some(PATH_TO_GENESIS.into()),
                genesis_key_pair.public_key().clone(),
                None,
            )
            .submit_genesis_with(signature)
            .set_health_check(self.health_check)
            .build();

            (name.clone(), service)
        };

        let services = peers_iter
            .map(|(name, peer)| {
                let service = DockerComposeServiceBuilder::new(
                    chain_id.clone(),
                    peer.clone(),
                    service_source.clone(),
                    volumes.clone(),
                    trusted_peers
                        .iter()
                        .filter(|trusted_peer| {
                            trusted_peer.public_key() != peer.key_pair.public_key()
                        })
                        .cloned()
                        .collect(),
                    None,
                    genesis_key_pair.public_key().clone(),
                    None,
                )
                .set_health_check(self.health_check)
                .build();

                (name.clone(), service)
            })
            .chain(std::iter::once(first_peer_service))
            .collect();

        let compose = DockerCompose::new(services);
        Ok(compose)
    }

    pub(crate) fn build_and_write(&self, banner_enabled: bool) -> color_eyre::Result<()> {
        let target_file = self.target_file;
        let compose = self
            .build()
            .wrap_err("Failed to build a docker compose file")?;
        compose.write_file(&target_file.path, banner_enabled)
    }
}

fn generate_key_pair(base_seed: Option<&[u8]>, additional_seed: &[u8]) -> KeyPair {
    base_seed.map_or_else(KeyPair::random, |base| {
        let seed: Vec<_> = base.iter().chain(additional_seed).copied().collect();
        KeyPair::from_seed(seed, Algorithm::default())
    })
}

fn generate_hex_string_signature(chain_id: &ChainId, genesis_key_pair: &KeyPair) -> String {
    let manifest_dir = Path::new(env!("CARGO_MANIFEST_DIR"));
    let raw_block = iroha_genesis::RawGenesisBlock::from_path(
        manifest_dir.join("../../configs/swarm/genesis.json"),
    )
    .expect("Could not find genesis.json. Path should be changed");
    if cfg!(test) {
        "9030303030303030302d303030302d303030302d303030302d303030303030303030303030e36c2066000000004034f13504008039e5bf092186facc358770792a493ca98a83740643a3d41389483cf334f748c8010106fd66ada31d1fed20f6ade6dfd0a033d07b89258a426624777ed1076b205661306958d51629b7a2df0f7251b0df5f02f53beaf504fffe5a7557ec1af0ac2a03".into()
    } else {
        iroha_genesis::GenesisNetwork::new_genesis_signature(raw_block, chain_id, genesis_key_pair)
            .to_hex_string()
    }
}

mod peer_generator {
    use std::{collections::BTreeMap, num::NonZeroU16};

    use color_eyre::Report;
    use iroha_crypto::KeyPair;
    use iroha_data_model::prelude::PeerId;
    use iroha_primitives::addr::{SocketAddr, SocketAddrHost};

    const BASE_PORT_P2P: u16 = 1337;
    const BASE_PORT_API: u16 = 8080;
    const BASE_SERVICE_NAME: &'_ str = "iroha";

    #[derive(Clone)]
    pub struct Peer {
        pub name: String,
        pub port_p2p: u16,
        pub port_api: u16,
        pub key_pair: KeyPair,
    }

    impl Peer {
        /// [`PeerId`] with an address containing service name as a host, therefore reachable
        /// from other Docker Compose services.
        pub fn id_as_a_service(&self) -> PeerId {
            let address = SocketAddr::Host(SocketAddrHost {
                host: self.name.clone().into(),
                port: self.port_p2p,
            });

            PeerId::new(address.clone(), self.key_pair.public_key().clone())
        }
    }

    pub fn generate_peers(
        peers: NonZeroU16,
        base_seed: Option<&[u8]>,
    ) -> Result<BTreeMap<String, Peer>, Report> {
        (0u16..peers.get())
            .map(|i| {
                let service_name = format!("{BASE_SERVICE_NAME}{i}");

                let key_pair = super::generate_key_pair(base_seed, service_name.as_bytes());

                let peer = Peer {
                    name: service_name.clone(),
                    port_p2p: BASE_PORT_P2P + i,
                    port_api: BASE_PORT_API + i,
                    key_pair,
                };

                Ok((service_name, peer))
            })
            .collect()
    }
}

#[derive(Debug)]
pub enum ResolvedImageSource {
    Image { name: String },
    Build { path: AbsolutePath },
}

impl TryFrom<SourceParsed> for ResolvedImageSource {
    type Error = color_eyre::Report;

    fn try_from(value: SourceParsed) -> Result<Self, Self::Error> {
        let resolved = match value {
            SourceParsed::Image { name } => Self::Image { name },
            SourceParsed::Build { path: relative } => {
                let absolute =
                    AbsolutePath::absolutize(&relative).wrap_err("Failed to resolve build path")?;
                Self::Build { path: absolute }
            }
        };

        Ok(resolved)
    }
}

#[cfg(test)]
mod tests {
    use std::{
        collections::{BTreeMap, BTreeSet, HashMap, HashSet},
        path::{Path, PathBuf},
        str::FromStr,
    };

    use iroha_config::{
        base::{FromEnv, TestEnv, UnwrapPartial},
        parameters::user::{CliContext, RootPartial},
    };
    use iroha_crypto::KeyPair;
    use iroha_primitives::addr::{socket_addr, SocketAddr};
    use path_absolutize::Absolutize;

    use super::*;

    impl AbsolutePath {
        pub(crate) fn from_virtual(path: &PathBuf, virtual_root: impl AsRef<Path> + Sized) -> Self {
            let path = path
                .absolutize_virtually(virtual_root)
                .unwrap()
                .to_path_buf();
            Self { path }
        }
    }

    impl From<FullPeerEnv> for TestEnv {
        fn from(peer_env: FullPeerEnv) -> Self {
            let json = serde_json::to_string(&peer_env).expect("Must be serializable");
            let env: HashMap<_, String> =
                serde_json::from_str(&json).expect("Must be deserializable into a hash map");
            Self::with_map(env)
        }
    }

    impl From<CompactPeerEnv> for TestEnv {
        fn from(value: CompactPeerEnv) -> Self {
            let full: FullPeerEnv = value.into();
            full.into()
        }
    }

    #[test]
    fn default_config_with_swarm_env_is_exhaustive() {
        let key_pair = KeyPair::from_seed(vec![1, 5, 1, 2, 2, 3, 4, 1, 2, 3], Algorithm::default());
        let chain_id = ChainId::from("00000000-0000-0000-0000-000000000000");
        let env: TestEnv = CompactPeerEnv {
            chain_id: chain_id.clone(),
            key_pair: key_pair.clone(),
            genesis_file: Some(PATH_TO_GENESIS.into()),
            genesis_public_key: key_pair.public_key().clone(),
            genesis_signature: Some(generate_hex_string_signature(&chain_id, &key_pair)),
            p2p_addr: socket_addr!(127.0.0.1:1337),
            api_addr: socket_addr!(127.0.0.1:1338),
            trusted_peers: {
                let mut set = BTreeSet::new();
                set.insert(PeerId::new(
                    socket_addr!(127.0.0.1:8081),
                    KeyPair::random().into_parts().0,
                ));
                set
            },
        }
        .into();

        let _cfg = RootPartial::from_env(&env)
            .expect("valid env")
            .unwrap_partial()
            .expect("should not fail as input has all required fields")
            .parse(CliContext {
                submit_genesis: true,
            })
            .expect("should not fail as input is valid");

        assert_eq!(env.unvisited(), HashSet::new());
    }

    #[test]
    fn serialize_image_source() {
        let source = ServiceSource::Image("hyperledger/iroha2:stable".to_owned());
        let serialised = serde_json::to_string(&source).unwrap();
        assert_eq!(serialised, r#"{"image":"hyperledger/iroha2:stable"}"#);
    }

    #[test]
    fn serialize_docker_compose() {
        let compose = DockerCompose {
            version: DockerComposeVersion,
            services: {
                let mut map = BTreeMap::new();

                let chain_id = ChainId::from("00000000-0000-0000-0000-000000000000");
                let key_pair =
                    KeyPair::from_seed(vec![1, 5, 1, 2, 2, 3, 4, 1, 2, 3], Algorithm::default());

                map.insert(
                    "iroha0".to_owned(),
                    DockerComposeService {
                        platform: PlatformArchitecture,
                        source: ServiceSource::Build(PathBuf::from(".")),
                        environment: CompactPeerEnv {
                            chain_id: chain_id.clone(),
                            key_pair: key_pair.clone(),
                            genesis_file: Some(PATH_TO_GENESIS.into()),
                            genesis_public_key: key_pair.public_key().clone(),
                            genesis_signature: Some(generate_hex_string_signature(
                                &chain_id, &key_pair,
                            )),
                            p2p_addr: SocketAddr::from_str("iroha1:1339").unwrap(),
                            api_addr: SocketAddr::from_str("iroha1:1338").unwrap(),
                            trusted_peers: BTreeSet::new(),
                        }
                        .into(),
                        ports: vec![
                            PairColon(1337, 1337),
                            PairColon(8080, 8080),
                            PairColon(8081, 8081),
                        ],
                        volumes: vec![PairColon(
                            "./configs/peer/legacy_stable".to_owned(),
                            "/config".to_owned(),
                        )],
                        init: AlwaysTrue,
                        command: ServiceCommand::SubmitGenesis,
                        healthcheck: None,
                    },
                );

                map
            },
        };

        let actual = serde_yaml::to_string(&compose).expect("Should be serialisable");
        #[allow(clippy::needless_raw_string_hashes)]
        let expected = expect_test::expect![[r#"
            version: '3.8'
            services:
              iroha0:
                build: .
                platform: linux/amd64
                environment:
                  CHAIN_ID: 00000000-0000-0000-0000-000000000000
                  PUBLIC_KEY: ed012039E5BF092186FACC358770792A493CA98A83740643A3D41389483CF334F748C8
                  PRIVATE_KEY_ALGORITHM: ed25519
                  PRIVATE_KEY_PAYLOAD: db9d90d20f969177bd5882f9fe211d14d1399d5440d04e3468783d169bbc4a8e39e5bf092186facc358770792a493ca98a83740643a3d41389483cf334f748c8
                  P2P_ADDRESS: iroha1:1339
                  API_ADDRESS: iroha1:1338
                  GENESIS_FILE: /config/genesis.json
                  GENESIS_PUBLIC_KEY: ed012039E5BF092186FACC358770792A493CA98A83740643A3D41389483CF334F748C8
                  GENESIS_SIGNATURE: 9030303030303030302d303030302d303030302d303030302d303030303030303030303030e36c2066000000004034f13504008039e5bf092186facc358770792a493ca98a83740643a3d41389483cf334f748c8010106fd66ada31d1fed20f6ade6dfd0a033d07b89258a426624777ed1076b205661306958d51629b7a2df0f7251b0df5f02f53beaf504fffe5a7557ec1af0ac2a03
                ports:
                - 1337:1337
                - 8080:8080
                - 8081:8081
                volumes:
                - ./configs/peer/legacy_stable:/config
                init: true
                command: iroha --submit-genesis
        "#]];
        expected.assert_eq(&actual);
    }

    #[test]
    fn empty_genesis_private_key_is_skipped_in_env() {
        let chain_id = ChainId::from("00000000-0000-0000-0000-000000000000");

        let key_pair = KeyPair::from_seed(vec![0, 1, 2], Algorithm::default());

        let env: FullPeerEnv = CompactPeerEnv {
            chain_id: chain_id.clone(),
            key_pair: key_pair.clone(),
            genesis_file: Some(PATH_TO_GENESIS.into()),
            genesis_public_key: key_pair.public_key().clone(),
            genesis_signature: Some(generate_hex_string_signature(&chain_id, &key_pair)),
            p2p_addr: SocketAddr::from_str("iroha0:1337").unwrap(),
            api_addr: SocketAddr::from_str("iroha0:1337").unwrap(),
            trusted_peers: BTreeSet::new(),
        }
        .into();

        let actual = serde_yaml::to_string(&env).unwrap();
        #[allow(clippy::needless_raw_string_hashes)]
        let expected = expect_test::expect![[r#"
            CHAIN_ID: 00000000-0000-0000-0000-000000000000
            PUBLIC_KEY: ed0120415388A90FA238196737746A70565D041CFB32EAA0C89FF8CB244C7F832A6EBD
            PRIVATE_KEY_ALGORITHM: ed25519
            PRIVATE_KEY_PAYLOAD: 6bf163fd75192b81a78cb20c5f8cb917f591ac6635f2577e6ca305c27a456a5d415388a90fa238196737746a70565d041cfb32eaa0c89ff8cb244c7f832a6ebd
            P2P_ADDRESS: iroha0:1337
            API_ADDRESS: iroha0:1337
            GENESIS_FILE: /config/genesis.json
            GENESIS_PUBLIC_KEY: ed0120415388A90FA238196737746A70565D041CFB32EAA0C89FF8CB244C7F832A6EBD
            GENESIS_SIGNATURE: 9030303030303030302d303030302d303030302d303030302d303030303030303030303030e36c2066000000004034f13504008039e5bf092186facc358770792a493ca98a83740643a3d41389483cf334f748c8010106fd66ada31d1fed20f6ade6dfd0a033d07b89258a426624777ed1076b205661306958d51629b7a2df0f7251b0df5f02f53beaf504fffe5a7557ec1af0ac2a03
        "#]];
        expected.assert_eq(&actual);
    }

    #[test]
    #[allow(clippy::too_many_lines)]
    fn generate_peers_deterministically() {
        let root = Path::new("/");
        let seed = Some(b"iroha".to_vec());
        let seed = seed.as_deref();

        let composed = DockerComposeBuilder {
            target_file: &AbsolutePath::from_virtual(
                &PathBuf::from("/test/docker-compose.yml"),
                root,
            ),
            config_dir: &AbsolutePath::from_virtual(&PathBuf::from("/test/config"), root),
            peers: 4.try_into().unwrap(),
            image_source: ResolvedImageSource::Build {
                path: AbsolutePath::from_virtual(&PathBuf::from("/test/iroha-cloned"), root),
            },
            seed,
            health_check: true,
            key_pair: None,
            signature: None,
        }
        .build()
        .expect("should build with no errors");

        let yaml = serde_yaml::to_string(&composed).unwrap();
        let expected = expect_test::expect![[r#"
            version: '3.8'
            services:
              iroha0:
                build: ./iroha-cloned
                platform: linux/amd64
                environment:
                  CHAIN_ID: 00000000-0000-0000-0000-000000000000
                  PUBLIC_KEY: ed0120F0321EB4139163C35F88BF78520FF7071499D7F4E79854550028A196C7B49E13
                  PRIVATE_KEY_ALGORITHM: ed25519
                  PRIVATE_KEY_PAYLOAD: 5f8d1291bf6b762ee748a87182345d135fd167062857aa4f20ba39f25e74c4b0f0321eb4139163c35f88bf78520ff7071499d7f4e79854550028a196c7b49e13
                  P2P_ADDRESS: 0.0.0.0:1337
                  API_ADDRESS: 0.0.0.0:8080
                  GENESIS_FILE: /config/genesis.json
                  GENESIS_PUBLIC_KEY: ed01203420F48A9EEB12513B8EB7DAF71979CE80A1013F5F341C10DCDA4F6AA19F97A9
                  GENESIS_SIGNATURE: 9030303030303030302d303030302d303030302d303030302d303030303030303030303030e36c2066000000004034f13504008039e5bf092186facc358770792a493ca98a83740643a3d41389483cf334f748c8010106fd66ada31d1fed20f6ade6dfd0a033d07b89258a426624777ed1076b205661306958d51629b7a2df0f7251b0df5f02f53beaf504fffe5a7557ec1af0ac2a03
                  SUMERAGI_TRUSTED_PEERS: '[{"address":"iroha2:1339","public_key":"ed0120312C1B7B5DE23D366ADCF23CD6DB92CE18B2AA283C7D9F5033B969C2DC2B92F4"},{"address":"iroha3:1340","public_key":"ed0120854457B2E3D6082181DA73DC01C1E6F93A72D0C45268DC8845755287E98A5DEE"},{"address":"iroha1:1338","public_key":"ed0120A88554AA5C86D28D0EEBEC497235664433E807881CD31E12A1AF6C4D8B0F026C"}]'
                ports:
                - 1337:1337
                - 8080:8080
                volumes:
                - ./config:/config
                init: true
                command: iroha --submit-genesis
                healthcheck:
                  test: test $(curl -s http://127.0.0.1:8080/status/blocks) -gt 0
                  interval: 2s
                  timeout: 1s
                  retries: 30
                  start_period: 4s
              iroha1:
                build: ./iroha-cloned
                platform: linux/amd64
                environment:
                  CHAIN_ID: 00000000-0000-0000-0000-000000000000
                  PUBLIC_KEY: ed0120A88554AA5C86D28D0EEBEC497235664433E807881CD31E12A1AF6C4D8B0F026C
                  PRIVATE_KEY_ALGORITHM: ed25519
                  PRIVATE_KEY_PAYLOAD: 8d34d2c6a699c61e7a9d5aabbbd07629029dfb4f9a0800d65aa6570113edb465a88554aa5c86d28d0eebec497235664433e807881cd31e12a1af6c4d8b0f026c
                  P2P_ADDRESS: 0.0.0.0:1338
                  API_ADDRESS: 0.0.0.0:8081
                  GENESIS_PUBLIC_KEY: ed01203420F48A9EEB12513B8EB7DAF71979CE80A1013F5F341C10DCDA4F6AA19F97A9
                  SUMERAGI_TRUSTED_PEERS: '[{"address":"iroha2:1339","public_key":"ed0120312C1B7B5DE23D366ADCF23CD6DB92CE18B2AA283C7D9F5033B969C2DC2B92F4"},{"address":"iroha3:1340","public_key":"ed0120854457B2E3D6082181DA73DC01C1E6F93A72D0C45268DC8845755287E98A5DEE"},{"address":"iroha0:1337","public_key":"ed0120F0321EB4139163C35F88BF78520FF7071499D7F4E79854550028A196C7B49E13"}]'
                ports:
                - 1338:1338
                - 8081:8081
                volumes:
                - ./config:/config
                init: true
                healthcheck:
                  test: test $(curl -s http://127.0.0.1:8081/status/blocks) -gt 0
                  interval: 2s
                  timeout: 1s
                  retries: 30
                  start_period: 4s
              iroha2:
                build: ./iroha-cloned
                platform: linux/amd64
                environment:
                  CHAIN_ID: 00000000-0000-0000-0000-000000000000
                  PUBLIC_KEY: ed0120312C1B7B5DE23D366ADCF23CD6DB92CE18B2AA283C7D9F5033B969C2DC2B92F4
                  PRIVATE_KEY_ALGORITHM: ed25519
                  PRIVATE_KEY_PAYLOAD: cf4515a82289f312868027568c0da0ee3f0fde7fef1b69deb47b19fde7cbc169312c1b7b5de23d366adcf23cd6db92ce18b2aa283c7d9f5033b969c2dc2b92f4
                  P2P_ADDRESS: 0.0.0.0:1339
                  API_ADDRESS: 0.0.0.0:8082
                  GENESIS_PUBLIC_KEY: ed01203420F48A9EEB12513B8EB7DAF71979CE80A1013F5F341C10DCDA4F6AA19F97A9
                  SUMERAGI_TRUSTED_PEERS: '[{"address":"iroha3:1340","public_key":"ed0120854457B2E3D6082181DA73DC01C1E6F93A72D0C45268DC8845755287E98A5DEE"},{"address":"iroha1:1338","public_key":"ed0120A88554AA5C86D28D0EEBEC497235664433E807881CD31E12A1AF6C4D8B0F026C"},{"address":"iroha0:1337","public_key":"ed0120F0321EB4139163C35F88BF78520FF7071499D7F4E79854550028A196C7B49E13"}]'
                ports:
                - 1339:1339
                - 8082:8082
                volumes:
                - ./config:/config
                init: true
                healthcheck:
                  test: test $(curl -s http://127.0.0.1:8082/status/blocks) -gt 0
                  interval: 2s
                  timeout: 1s
                  retries: 30
                  start_period: 4s
              iroha3:
                build: ./iroha-cloned
                platform: linux/amd64
                environment:
                  CHAIN_ID: 00000000-0000-0000-0000-000000000000
                  PUBLIC_KEY: ed0120854457B2E3D6082181DA73DC01C1E6F93A72D0C45268DC8845755287E98A5DEE
                  PRIVATE_KEY_ALGORITHM: ed25519
                  PRIVATE_KEY_PAYLOAD: ab0e99c2b845b4ac7b3e88d25a860793c7eb600a25c66c75cba0bae91e955aa6854457b2e3d6082181da73dc01c1e6f93a72d0c45268dc8845755287e98a5dee
                  P2P_ADDRESS: 0.0.0.0:1340
                  API_ADDRESS: 0.0.0.0:8083
                  GENESIS_PUBLIC_KEY: ed01203420F48A9EEB12513B8EB7DAF71979CE80A1013F5F341C10DCDA4F6AA19F97A9
                  SUMERAGI_TRUSTED_PEERS: '[{"address":"iroha2:1339","public_key":"ed0120312C1B7B5DE23D366ADCF23CD6DB92CE18B2AA283C7D9F5033B969C2DC2B92F4"},{"address":"iroha1:1338","public_key":"ed0120A88554AA5C86D28D0EEBEC497235664433E807881CD31E12A1AF6C4D8B0F026C"},{"address":"iroha0:1337","public_key":"ed0120F0321EB4139163C35F88BF78520FF7071499D7F4E79854550028A196C7B49E13"}]'
                ports:
                - 1340:1340
                - 8083:8083
                volumes:
                - ./config:/config
                init: true
                healthcheck:
                  test: test $(curl -s http://127.0.0.1:8083/status/blocks) -gt 0
                  interval: 2s
                  timeout: 1s
                  retries: 30
                  start_period: 4s
        "#]];
        expected.assert_eq(&yaml);
    }
}
