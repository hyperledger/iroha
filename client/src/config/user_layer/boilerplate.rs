//! Code to be generated by a proc macro in future

use std::{error::Error, fs::File, io::Read, path::Path};

use eyre::{eyre, Context};
use iroha_config::base::{
    Emitter, FromEnv, Merge, MissingFieldError, ParseEnvResult, UnwrapPartial, UnwrapPartialResult,
    UserDuration, UserField,
};
use iroha_crypto::{PrivateKey, PublicKey};
use iroha_data_model::{account::AccountId, ChainId};
use serde::Deserialize;

use crate::config::{
    base::{FromEnvResult, ReadEnv},
    user_layer::{Account, Api, OnlyHttpUrl, Root, Transaction},
    BasicAuth, DEFAULT_TRANSACTION_NONCE, DEFAULT_TRANSACTION_STATUS_TIMEOUT,
    DEFAULT_TRANSACTION_TIME_TO_LIVE,
};

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct RootPartial {
    pub chain_id: UserField<ChainId>,
    pub torii_url: UserField<OnlyHttpUrl>,
    pub basic_auth: UserField<BasicAuth>,
    pub account: AccountPartial,
    pub transaction: TransactionPartial,
}

impl RootPartial {
    pub fn new() -> Self {
        // TODO: gen with macro
        Default::default()
    }

    pub fn from_toml(path: impl AsRef<Path>) -> eyre::Result<Self> {
        let contents = {
            let mut contents = String::new();
            File::open(path.as_ref())
                .wrap_err_with(|| {
                    eyre!("cannot open file at location `{}`", path.as_ref().display())
                })?
                .read_to_string(&mut contents)?;
            contents
        };
        let layer: Self = toml::from_str(&contents).wrap_err("failed to parse toml")?;
        Ok(layer)
    }

    pub fn merge(mut self, other: Self) -> Self {
        Merge::merge(&mut self, other);
        self
    }
}

// FIXME: should config be read from ENV?
impl FromEnv for RootPartial {
    fn from_env<E: Error, R: ReadEnv<E>>(env: &R) -> FromEnvResult<Self>
    where
        Self: Sized,
    {
        let mut emitter = Emitter::new();

        let torii_url =
            ParseEnvResult::parse_simple(&mut emitter, env, "TORII_URL", "torii_url").into();

        emitter.finish()?;

        Ok(Self {
            chain_id: None.into(),
            torii_url,
            basic_auth: None.into(),
            account: AccountPartial::default(),
            transaction: TransactionPartial::default(),
        })
    }
}

impl UnwrapPartial for RootPartial {
    type Output = Root;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        let mut emitter = Emitter::new();

        if self.chain_id.is_none() {
            emitter.emit_missing_field("chain_id");
        }
        if self.torii_url.is_none() {
            emitter.emit_missing_field("torii_url");
        }
        let account = emitter.try_unwrap_partial(self.account);
        let transaction = emitter.try_unwrap_partial(self.transaction);

        emitter.finish()?;

        Ok(Root {
            chain_id: self.chain_id.get().unwrap(),
            torii_url: self.torii_url.get().unwrap(),
            basic_auth: self.basic_auth.get(),
            account: account.unwrap(),
            transaction: transaction.unwrap(),
        })
    }
}

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct AccountPartial {
    pub id: UserField<AccountId>,
    pub public_key: UserField<PublicKey>,
    pub private_key: UserField<PrivateKey>,
}

impl UnwrapPartial for AccountPartial {
    type Output = Account;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        let mut emitter = Emitter::new();

        if self.id.is_none() {
            emitter.emit_missing_field("account.id");
        }
        if self.public_key.is_none() {
            emitter.emit_missing_field("account.public_key");
        }
        if self.private_key.is_none() {
            emitter.emit_missing_field("account.private_key");
        }

        emitter.finish()?;

        Ok(Account {
            id: self.id.get().unwrap(),
            public_key: self.public_key.get().unwrap(),
            private_key: self.private_key.get().unwrap(),
        })
    }
}

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct TransactionPartial {
    pub time_to_live: UserField<UserDuration>,
    pub status_timeout: UserField<UserDuration>,
    pub nonce: UserField<bool>,
}

impl UnwrapPartial for TransactionPartial {
    type Output = Transaction;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        Ok(Transaction {
            time_to_live: self
                .time_to_live
                .get()
                .map_or(DEFAULT_TRANSACTION_TIME_TO_LIVE, UserDuration::get),
            status_timeout: self
                .status_timeout
                .get()
                .map_or(DEFAULT_TRANSACTION_STATUS_TIMEOUT, UserDuration::get),
            nonce: self.nonce.get().unwrap_or(DEFAULT_TRANSACTION_NONCE),
        })
    }
}
